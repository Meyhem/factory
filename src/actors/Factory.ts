import { Actor, Engine, Color, Text, Font, FontUnit, Vector, vec } from 'excalibur';
import { Inventory } from '../core/Inventory';
import { Recipe, PRODUCTS } from '../data/registry';
import { LogisticsBroker } from '../systems/LogisticsBroker';

export enum FactoryState {
    IDLE = 'idle',
    CONSUMING = 'consuming',
    PROCESSING = 'processing',
    PRODUCING = 'producing',
}

export class Factory extends Actor {
    public inputInventory: Inventory;
    public outputInventory: Inventory;
    public activeRecipe: Recipe | null = null;

    private currentState: FactoryState = FactoryState.IDLE;
    private tickCounter: number = 0;
    private debugText: Text;

    constructor(
        public name: string,
        inputCapacity: number,
        outputCapacity: number
    ) {
        super({ name, width: 40, height: 40, color: Color.Gray });
        this.inputInventory = new Inventory(inputCapacity);
        this.outputInventory = new Inventory(outputCapacity);

        this.debugText = new Text({
            text: '',
            font: new Font({ size: 10, unit: FontUnit.Px, family: 'monospace', color: Color.White })
        });

        const labelActor = new Actor({ pos: vec(0, -30) });
        labelActor.graphics.use(this.debugText);
        this.addChild(labelActor);
    }

    onPostUpdate(engine: Engine, delta: number) {
        this.debugText.text = `${this.name}\nIn: ${this.inputInventory.currentTotalMass}g\nOut: ${this.outputInventory.currentTotalMass}g\n${this.currentState}`;
    }

    onInitialize(engine: Engine) {
        // Visual setup can go here later
    }

    // Simplified tick-based update called by a robust TickManager or Engine update
    public tick() {
        this.checkTaskGeneration();

        if (!this.activeRecipe) return;

        switch (this.currentState) {
            case FactoryState.IDLE:
                this.checkInputs();
                break;
            case FactoryState.CONSUMING:
                this.consumeInputs();
                break;
            case FactoryState.PROCESSING:
                this.processRecipe();
                break;
            case FactoryState.PRODUCING:
                this.produceOutputs();
                break;
        }
    }

    private checkTaskGeneration() {
        const broker = LogisticsBroker.getInstance();

        // 1. Demand Logic (Input)
        if (this.activeRecipe) {
            for (const input of this.activeRecipe.inputs) {
                const current = this.inputInventory.getAmount(input.productId);
                const capacity = this.inputInventory.maxMassCapacity;
                const threshold = capacity * 0.5; // low stock

                if (current < threshold) {
                    // Request to fill up to capacity?
                    // Or just a batch?
                    // Simple: Request difference
                    const needed = capacity - current;
                    // TODO: Check if we already have pending tasks covering this?
                    // For MVP: blindly request. Broker/Mule needs to handle over-supply or reservation dedupe.
                    // BETTER: Broker should ignore duplicates? Or Actor tracks active tasks.
                    // Skipping dedupe for MVP speed, expect chaos (or smart Broker).
                    // Broker doesn't dedupe.

                    // Let's implement a randomized cooldown or only request if very low?
                    // Or just rely on "findTask" logic to handle it.

                    // IMPORTANT: To find "Source", we need to know WHO produces this.
                    // The Broker currently takes (source, target, product).
                    // Demand task means "I need X from ANYWHERE".
                    // Supply task means "I have X to go ANYWHERE".

                    // The current Broker.requestTransport(source, target, ...) expects a specific path.
                    // This implies the Factory knows where to get stuff.
                    // That's not ideal. The Broker should match Supply and Demand.

                    // RE-READ PLAN:
                    // "Supply Task: Generated by Factories when outputInventory > threshold"
                    // "Demand Task: Generated by Factories when inputInventory < threshold"

                    // If the plan implies Broker matches them, my Broker implementation is too simple (direct point-to-point).
                    // Or, the plan implies "I have Supply" and "I have Demand" are separate records, and Broker pairs them?
                    // My Broker currently `requestTransport(source, target...)`.

                    // Let's hack it:
                    // Factory "Broadcasts" availability?
                    // Or Factor "Looks up" suppliers?

                    // Let's look at `Miner`. It produces Iron Ore.
                    // `SteelFactory` needs Iron Ore.

                    // Factory needs to know `Miner` exists.
                    // In `main.ts` we created them.

                    // MVP Solution: Hardcode connections or simple lookup service.
                    // Since I can't easily change the Plan's architecture without big refactor,
                    // I will assume for this MVP that the System (LogisticsBroker or a higher manager)
                    // creates the routes, OR we implement a simple "Market".

                    // Let's modify Factory to just expose "Needs" and "Offers" and Main.ts or a wrapper creates tasks?
                    // No, Factory is an Actor.

                    // Let's assume the user wants the Factory to act.
                    // I will assume global knowledge of "IronMine" for now.
                    // Or iterating all actors.

                    // Hack: If I need Iron Ore, I ask "IronMine".
                    // If I need Coal, I ask "CoalMine".
                    let targetId = '';
                    if (input.productId === PRODUCTS.IRON_ORE) targetId = 'IronMine';
                    else if (input.productId === PRODUCTS.COAL) targetId = 'CoalMine';

                    if (targetId) {
                        broker.requestTransport(targetId, this.name, input.productId, needed);
                    }
                }
            }
        }

        // 2. Supply Logic (Output)
        // If output > threshold, we want to move it... WHERE?
        // To anyone who needs it? Or to a warehouse?
        // If SteelMill produces Steel, who consumes it? No one yet.
        // So Supply tasks might just sit there.

        this.activeRecipe?.outputs.forEach(output => {
            // If we have output, advertise it?
        });
    }

    private checkInputs() {
        if (!this.activeRecipe) return;

        // Check if we have enough mass for all inputs
        for (const input of this.activeRecipe.inputs) {
            if (this.inputInventory.getAmount(input.productId) < input.mass) {
                return; // Not enough inputs
            }
        }

        // If we have all inputs, transition to consuming
        this.currentState = FactoryState.CONSUMING;
    }

    private consumeInputs() {
        if (!this.activeRecipe) return;

        // Double check (atomic validation ideally happened in checkInputs but good to be safe)
        for (const input of this.activeRecipe.inputs) {
            if (!this.inputInventory.remove(input.productId, input.mass)) {
                // Should not happen if check passed and no one else stole it
                this.currentState = FactoryState.IDLE;
                return;
            }
        }

        this.tickCounter = 0;
        this.currentState = FactoryState.PROCESSING;
    }

    private processRecipe() {
        if (!this.activeRecipe) return;

        this.tickCounter++;
        if (this.tickCounter >= this.activeRecipe.durationTicks) {
            this.currentState = FactoryState.PRODUCING;
        }
    }

    private produceOutputs() {
        if (!this.activeRecipe) return;

        // Check if output has capacity
        // For simplicity, we check if we can add ALL outputs. 
        // If partially full, we wait.
        let canFit = true;
        for (const output of this.activeRecipe.outputs) {
            if (this.outputInventory.currentTotalMass + output.mass > this.outputInventory.maxMassCapacity) {
                canFit = false;
                break;
            }
        }

        if (canFit) {
            for (const output of this.activeRecipe.outputs) {
                this.outputInventory.add(output.productId, output.mass);
            }
            this.currentState = FactoryState.IDLE;
        }
        // Else stay in PRODUCING state (blocked)
    }
}
